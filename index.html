<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nexus | Knowledge Fusion</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Marked.js for Markdown parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/9.1.2/marked.min.js"></script>
    <!-- FontAwesome for Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <style>
        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1f2937; 
        }
        ::-webkit-scrollbar-thumb {
            background: #4b5563; 
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #6b7280; 
        }

        body {
            background-color: #0f0f0f;
            color: #e5e7eb;
            font-family: 'Inter', sans-serif;
            overflow: hidden; /* Prevent body scroll, handle in containers */
        }

        .editor-area {
            height: calc(100vh - 60px);
        }

        .markdown-preview h1 { font-size: 2em; font-weight: bold; margin-bottom: 0.5em; color: #fff; }
        .markdown-preview h2 { font-size: 1.5em; font-weight: bold; margin-top: 1em; margin-bottom: 0.5em; color: #e5e7eb; }
        .markdown-preview h3 { font-size: 1.25em; font-weight: bold; margin-top: 1em; margin-bottom: 0.5em; }
        .markdown-preview p { margin-bottom: 1em; line-height: 1.6; }
        .markdown-preview ul { list-style-type: disc; padding-left: 1.5em; margin-bottom: 1em; }
        .markdown-preview ol { list-style-type: decimal; padding-left: 1.5em; margin-bottom: 1em; }
        .markdown-preview blockquote { border-left: 4px solid #3b82f6; padding-left: 1em; font-style: italic; color: #9ca3af; margin-bottom: 1em; }
        .markdown-preview code { background-color: #374151; padding: 0.2em 0.4em; border-radius: 4px; font-family: monospace; font-size: 0.9em; }
        .markdown-preview pre { background-color: #1f2937; padding: 1em; border-radius: 8px; overflow-x: auto; margin-bottom: 1em; }
        .markdown-preview pre code { background-color: transparent; padding: 0; }
        .markdown-preview a { color: #60a5fa; text-decoration: underline; }
        .markdown-preview hr { border-color: #374151; margin: 2em 0; }

        /* Wikilink styling */
        .wikilink {
            color: #a78bfa;
            cursor: pointer;
            text-decoration: none;
            background: rgba(139, 92, 246, 0.1);
            padding: 0 4px;
            border-radius: 4px;
            transition: all 0.2s;
        }
        .wikilink:hover {
            background: rgba(139, 92, 246, 0.3);
            color: #c4b5fd;
        }
        .wikilink.is-missing {
            color: #f87171;
            background: rgba(248, 113, 113, 0.1);
        }

        /* Graph Canvas Container */
        #graph-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0f0f0f;
            z-index: 40;
            display: none; /* Hidden by default */
        }
        
        .sidebar-item.active {
            background-color: #374151;
            border-left: 3px solid #8b5cf6;
        }
    </style>
</head>
<body class="flex h-screen w-screen">

    <!-- Sidebar -->
    <aside class="w-64 bg-gray-900 border-r border-gray-800 flex flex-col flex-shrink-0 z-50">
        <div class="p-4 border-b border-gray-800 flex items-center justify-between">
            <h1 class="text-xl font-bold tracking-tight text-white"><i class="fa-solid fa-circle-nodes text-purple-500 mr-2"></i>Nexus</h1>
        </div>
        
        <!-- Search -->
        <div class="p-2">
            <input type="text" id="search-input" placeholder="Search pages..." class="w-full bg-gray-800 border border-gray-700 rounded px-3 py-2 text-sm focus:outline-none focus:border-purple-500 text-gray-300">
        </div>

        <!-- Page List -->
        <div id="page-list" class="flex-1 overflow-y-auto p-2 space-y-1">
            <!-- Pages injected here -->
        </div>

        <!-- Sidebar Footer -->
        <div class="p-3 border-t border-gray-800 bg-gray-900">
            <button id="btn-new-page" class="w-full bg-purple-600 hover:bg-purple-700 text-white py-2 rounded flex items-center justify-center transition-colors">
                <i class="fa-solid fa-plus mr-2"></i> New Page
            </button>
            <div class="flex justify-between mt-3 text-gray-400 text-xs">
                <button id="btn-export" class="hover:text-white"><i class="fa-solid fa-download"></i> Export</button>
                <input type="file" id="file-import" class="hidden" accept=".json">
                <button id="btn-import" class="hover:text-white"><i class="fa-solid fa-upload"></i> Import</button>
            </div>
        </div>
    </aside>

    <!-- Main Content -->
    <main class="flex-1 flex flex-col relative h-full overflow-hidden">
        
        <!-- Top Bar -->
        <header class="h-14 bg-gray-900 border-b border-gray-800 flex items-center justify-between px-6 flex-shrink-0 z-50">
            <div class="flex items-center space-x-2 overflow-hidden">
                <i class="fa-regular fa-file-lines text-gray-500"></i>
                <input type="text" id="note-title" class="bg-transparent text-lg font-medium focus:outline-none text-white w-96 placeholder-gray-600" placeholder="Untitled Page">
            </div>
            
            <div class="flex items-center space-x-3">
                <span id="save-status" class="text-xs text-gray-500 mr-2">Saved</span>
                <button id="btn-delete" class="text-gray-500 hover:text-red-400 transition-colors" title="Delete Page">
                    <i class="fa-regular fa-trash-can"></i>
                </button>
                <div class="h-6 w-px bg-gray-700 mx-2"></div>
                <button id="btn-toggle-view" class="text-gray-400 hover:text-white px-3 py-1 rounded hover:bg-gray-800 transition-colors flex items-center" title="Toggle Graph View">
                    <i class="fa-solid fa-share-nodes mr-2"></i> Graph View
                </button>
            </div>
        </header>

        <!-- Editor / Preview Container -->
        <div id="workspace" class="flex flex-1 overflow-hidden relative z-10">
            <!-- Markdown Editor -->
            <textarea id="markdown-input" class="w-1/2 h-full bg-[#0f0f0f] text-gray-300 p-8 resize-none focus:outline-none font-mono text-sm leading-relaxed border-r border-gray-800 overflow-y-auto" placeholder="Start typing... Use [[Page Name]] to link."></textarea>
            
            <!-- Preview -->
            <div id="markdown-preview" class="w-1/2 h-full bg-[#0f0f0f] text-gray-300 p-8 overflow-y-auto markdown-preview"></div>
        </div>

        <!-- Graph Container (Canvas) -->
        <div id="graph-container">
            <canvas id="graph-canvas"></canvas>
            <div class="absolute top-4 right-4 bg-gray-800 bg-opacity-80 p-2 rounded text-xs text-gray-400">
                <p><i class="fa-solid fa-mouse"></i> Drag to move</p>
                <p><i class="fa-solid fa-computer-mouse"></i> Scroll to zoom</p>
                <p><i class="fa-solid fa-arrow-pointer"></i> Click node to open</p>
            </div>
            <button id="btn-close-graph" class="absolute top-4 left-4 bg-gray-800 text-white px-4 py-2 rounded shadow-lg hover:bg-gray-700 z-50">
                <i class="fa-solid fa-arrow-left mr-2"></i> Back to Editor
            </button>
        </div>

    </main>

    <script>
        // --- Data Structure & State ---
        let notes = [];
        let activeNoteId = null;
        let isGraphOpen = false;

        // --- Initial Data ---
        const generateId = () => '_' + Math.random().toString(36).substr(2, 9);
        const defaultNote = {
            id: generateId(),
            title: 'Welcome to Nexus',
            content: '# Welcome to Nexus\n\nThis is a fusion of **Notion**-like editing and **Obsidian**-like graph visualization.\n\n## Features\n- Write in **Markdown**\n- Use `[[WikiLinks]]` to connect thoughts.\n- Click **Graph View** in the top right to see connections.\n\nTry clicking this link: [[My First Idea]]\n',
            timestamp: Date.now()
        };

        // --- DOM Elements ---
        const el = {
            pageList: document.getElementById('page-list'),
            noteTitle: document.getElementById('note-title'),
            mdInput: document.getElementById('markdown-input'),
            mdPreview: document.getElementById('markdown-preview'),
            btnNew: document.getElementById('btn-new-page'),
            btnDelete: document.getElementById('btn-delete'),
            btnToggleView: document.getElementById('btn-toggle-view'),
            btnCloseGraph: document.getElementById('btn-close-graph'),
            graphContainer: document.getElementById('graph-container'),
            graphCanvas: document.getElementById('graph-canvas'),
            searchInput: document.getElementById('search-input'),
            saveStatus: document.getElementById('save-status'),
            btnExport: document.getElementById('btn-export'),
            btnImport: document.getElementById('btn-import'),
            fileImport: document.getElementById('file-import'),
        };

        // --- Storage Logic ---
        function loadNotes() {
            const stored = localStorage.getItem('nexus_notes');
            if (stored) {
                notes = JSON.parse(stored);
                // Ensure legacy notes have timestamps
                notes.forEach(n => { if (!n.timestamp) n.timestamp = Date.now(); });
            } else {
                notes = [defaultNote];
                createNote('My First Idea', 'This is a new node in your knowledge graph! Link back to [[Welcome to Nexus]].');
            }
            
            // Sort by recent
            notes.sort((a,b) => b.timestamp - a.timestamp);
            
            if (notes.length > 0) {
                setActiveNote(notes[0].id);
            }
            renderSidebar();
        }

        function saveNotes() {
            localStorage.setItem('nexus_notes', JSON.stringify(notes));
            el.saveStatus.innerText = 'Saved';
            setTimeout(() => el.saveStatus.innerText = '', 2000);
            renderSidebar(); // Update sidebar if title changed
        }

        function createNote(title = "Untitled Page", content = "") {
            const newNote = {
                id: generateId(),
                title: title,
                content: content,
                timestamp: Date.now()
            };
            notes.unshift(newNote);
            saveNotes();
            setActiveNote(newNote.id);
            return newNote;
        }

        function deleteCurrentNote() {
            if (!confirm("Are you sure you want to delete this page?")) return;
            notes = notes.filter(n => n.id !== activeNoteId);
            if (notes.length === 0) {
                createNote();
            } else {
                setActiveNote(notes[0].id);
            }
            saveNotes();
        }

        // --- Core UI Logic ---
        function setActiveNote(id) {
            activeNoteId = id;
            const note = notes.find(n => n.id === id);
            if (!note) return;

            el.noteTitle.value = note.title;
            el.mdInput.value = note.content;
            updatePreview();
            renderSidebar();
            
            // Close graph if open
            if (isGraphOpen) toggleGraphView();
        }

        function getNoteByTitle(title) {
            return notes.find(n => n.title.toLowerCase() === title.toLowerCase());
        }

        function handleWikiClick(title) {
            const existing = getNoteByTitle(title);
            if (existing) {
                setActiveNote(existing.id);
            } else {
                // Create new note
                createNote(title, `# ${title}\n\nLinked from another page.`);
            }
        }

        // --- Markdown & Parsing ---
        function updatePreview() {
            const rawText = el.mdInput.value;
            
            // 1. Parse WikiLinks [[Page]]
            // We do this BEFORE marked parses MD to avoid conflicts, 
            // or we can use a custom renderer. Regex replacement is simpler here.
            // We replace [[Link]] with a special span we can catch click events on.
            
            const wikiLinkRegex = /\[\[(.*?)\]\]/g;
            
            // We process the markdown first using Marked
            let html = marked.parse(rawText);

            // Now we have to be careful. Marked might put [[ ]] inside <p>. 
            // A safer way for a simple app: Replace in raw text with a temporary token, render, then replace token.
            // Or, simpler: Post-process HTML text content.
            
            // Let's use a custom renderer approach for precision.
            const renderer = new marked.Renderer();
            const originalParagraph = renderer.paragraph.bind(renderer);
            
            // We can just do a simple text replacement on the resulting HTML string 
            // This is "good enough" for a prototype, though edge cases exist in code blocks.
            
            // Better approach: Replace [[...]] in raw text with a unique HTML string before parsing?
            // No, code blocks would break.
            
            // Let's stick to: simple regex on the text node parts of HTML is hard.
            // Let's try: Pre-process raw text, replace [[Title]] with <a href="#" onclick="...">Title</a> 
            // BUT, replace distinct from code blocks.
            
            // SIMPLEST ROBUST METHOD:
            // Use marked.js extension or tokenizer.
            // For this single file, let's use a "Text Replace" that respects Marked.
            // Actually, just raw replacement works 99% of the time for personal wikis if you don't put [[ ]] in code blocks.
            
            const processedHTML = html.replace(wikiLinkRegex, (match, p1) => {
                const title = p1;
                const exists = notes.some(n => n.title.toLowerCase() === title.toLowerCase());
                const className = exists ? 'wikilink' : 'wikilink is-missing';
                return `<span class="${className}" onclick="handleWikiClick('${title.replace(/'/g, "\\'")}')">${title}</span>`;
            });

            el.mdPreview.innerHTML = processedHTML;

            // Update active note object
            const note = notes.find(n => n.id === activeNoteId);
            if (note) {
                note.content = rawText;
                note.timestamp = Date.now();
                saveNotes();
            }
        }

        // --- Sidebar Rendering ---
        function renderSidebar() {
            const filter = el.searchInput.value.toLowerCase();
            el.pageList.innerHTML = '';
            
            notes.forEach(note => {
                if (note.title.toLowerCase().includes(filter)) {
                    const div = document.createElement('div');
                    div.className = `sidebar-item px-3 py-2 text-sm text-gray-300 cursor-pointer hover:bg-gray-800 rounded transition-colors truncate ${note.id === activeNoteId ? 'active text-white font-medium' : ''}`;
                    div.innerHTML = `<i class="fa-regular fa-file-lines mr-2 opacity-50"></i> ${note.title || 'Untitled'}`;
                    div.onclick = () => setActiveNote(note.id);
                    el.pageList.appendChild(div);
                }
            });
        }

        // --- Graph Visualization (Canvas Force Directed) ---
        let graphNodes = [];
        let graphLinks = [];
        let animationFrameId;
        let ctx = el.graphCanvas.getContext('2d');
        let transform = { x: 0, y: 0, k: 1 }; // Pan/Zoom
        let isDragging = false;
        let draggedNode = null;
        let dragStart = { x: 0, y: 0 };

        function initGraph() {
            const width = el.graphContainer.offsetWidth;
            const height = el.graphContainer.offsetHeight;
            el.graphCanvas.width = width;
            el.graphCanvas.height = height;
            
            // 1. Build Graph Data
            graphNodes = notes.map(n => ({
                id: n.id,
                title: n.title,
                x: Math.random() * width,
                y: Math.random() * height,
                vx: 0,
                vy: 0,
                radius: 20 + (n.content.length / 100) // Size based on content length (capped later)
            }));
            
            // Cap radius
            graphNodes.forEach(n => n.radius = Math.min(Math.max(n.radius, 5), 15));

            // Build Links based on Wikilinks [[ ]]
            graphLinks = [];
            notes.forEach(sourceNote => {
                const regex = /\[\[(.*?)\]\]/g;
                let match;
                while ((match = regex.exec(sourceNote.content)) !== null) {
                    const targetTitle = match[1];
                    const targetNote = notes.find(n => n.title.toLowerCase() === targetTitle.toLowerCase());
                    if (targetNote) {
                        graphLinks.push({
                            source: sourceNote.id,
                            target: targetNote.id
                        });
                    }
                }
            });

            // Center camera
            transform.x = width / 2;
            transform.y = height / 2;
            
            animateGraph();
        }

        function animateGraph() {
            if (!isGraphOpen) return;

            updatePhysics();
            drawGraph();
            animationFrameId = requestAnimationFrame(animateGraph);
        }

        function updatePhysics() {
            const repulsion = 500;
            const attraction = 0.01;
            const centerPull = 0.005;
            const damping = 0.85;

            // Repulsion (Nodes push apart)
            for (let i = 0; i < graphNodes.length; i++) {
                for (let j = i + 1; j < graphNodes.length; j++) {
                    const a = graphNodes[i];
                    const b = graphNodes[j];
                    let dx = b.x - a.x;
                    let dy = b.y - a.y;
                    let distSq = dx*dx + dy*dy;
                    if (distSq === 0) { dx = 1; dy = 1; distSq = 2; } // Avoid div by zero
                    if (distSq < 40000) { // Only calculate if close enough
                        const f = repulsion / distSq;
                        const dist = Math.sqrt(distSq);
                        const fx = (dx / dist) * f;
                        const fy = (dy / dist) * f;
                        
                        b.vx += fx;
                        b.vy += fy;
                        a.vx -= fx;
                        a.vy -= fy;
                    }
                }
            }

            // Attraction (Links pull together)
            graphLinks.forEach(link => {
                const source = graphNodes.find(n => n.id === link.source);
                const target = graphNodes.find(n => n.id === link.target);
                if (source && target) {
                    const dx = target.x - source.x;
                    const dy = target.y - source.y;
                    
                    source.vx += dx * attraction;
                    source.vy += dy * attraction;
                    target.vx -= dx * attraction;
                    target.vy -= dy * attraction;
                }
            });

            // Center Pull (Gravity towards middle)
            graphNodes.forEach(node => {
                node.vx -= node.x * centerPull;
                node.vy -= node.y * centerPull;
                
                // Update Pos
                if (node !== draggedNode) {
                    node.x += node.vx;
                    node.y += node.vy;
                }
                
                // Damping (Friction)
                node.vx *= damping;
                node.vy *= damping;
            });
        }

        function drawGraph() {
            // Clear
            ctx.clearRect(0, 0, el.graphCanvas.width, el.graphCanvas.height);
            
            ctx.save();
            // Apply Zoom/Pan
            ctx.translate(transform.x, transform.y);
            ctx.scale(transform.k, transform.k);

            // Draw Links
            ctx.strokeStyle = '#4b5563';
            ctx.lineWidth = 1;
            ctx.beginPath();
            graphLinks.forEach(link => {
                const source = graphNodes.find(n => n.id === link.source);
                const target = graphNodes.find(n => n.id === link.target);
                if (source && target) {
                    ctx.moveTo(source.x, source.y);
                    ctx.lineTo(target.x, target.y);
                }
            });
            ctx.stroke();

            // Draw Nodes
            graphNodes.forEach(node => {
                // Circle
                ctx.beginPath();
                ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
                
                // Highlight active node
                if (node.id === activeNoteId) {
                    ctx.fillStyle = '#a78bfa'; // Purple Light
                    ctx.shadowColor = '#8b5cf6';
                    ctx.shadowBlur = 10;
                } else {
                    ctx.fillStyle = '#6b7280'; // Gray
                    ctx.shadowBlur = 0;
                }
                
                ctx.fill();
                ctx.closePath();

                // Text Label
                ctx.fillStyle = '#e5e7eb';
                ctx.font = '10px Inter';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(node.title, node.x, node.y + node.radius + 12);
            });

            ctx.restore();
        }

        // --- Graph Interactions ---
        function toggleGraphView() {
            isGraphOpen = !isGraphOpen;
            if (isGraphOpen) {
                el.graphContainer.style.display = 'block';
                initGraph();
            } else {
                el.graphContainer.style.display = 'none';
                cancelAnimationFrame(animationFrameId);
            }
        }

        // Canvas Event Listeners
        el.graphCanvas.addEventListener('mousedown', e => {
            const rect = el.graphCanvas.getBoundingClientRect();
            const mx = (e.clientX - rect.left - transform.x) / transform.k;
            const my = (e.clientY - rect.top - transform.y) / transform.k;
            
            // Check node click
            draggedNode = graphNodes.find(n => {
                const dx = n.x - mx;
                const dy = n.y - my;
                return (dx*dx + dy*dy) < (n.radius * n.radius * 4); // Increased hit area
            });

            if (draggedNode) {
                isDragging = true;
            } else {
                // Pan start
                isDragging = true; // Reuse flag for panning
                dragStart = { x: e.clientX, y: e.clientY };
            }
        });

        el.graphCanvas.addEventListener('mousemove', e => {
            if (!isDragging) return;

            if (draggedNode) {
                const rect = el.graphCanvas.getBoundingClientRect();
                draggedNode.x = (e.clientX - rect.left - transform.x) / transform.k;
                draggedNode.y = (e.clientY - rect.top - transform.y) / transform.k;
                // Reset velocity
                draggedNode.vx = 0; 
                draggedNode.vy = 0;
            } else {
                // Panning
                const dx = e.clientX - dragStart.x;
                const dy = e.clientY - dragStart.y;
                transform.x += dx;
                transform.y += dy;
                dragStart = { x: e.clientX, y: e.clientY };
            }
        });

        el.graphCanvas.addEventListener('mouseup', e => {
            if (draggedNode) {
                // Check if it was a click (little movement) or drag
                // For simplicity, if mouseup on node, open it.
                // Need to calc distance from mousedown? 
                // Let's just say if not dragging heavily, open it.
                setActiveNote(draggedNode.id);
            }
            isDragging = false;
            draggedNode = null;
        });

        el.graphCanvas.addEventListener('wheel', e => {
            e.preventDefault();
            const zoomSensitivity = 0.001;
            const delta = -e.deltaY * zoomSensitivity;
            const newScale = Math.min(Math.max(0.1, transform.k + delta), 5);
            transform.k = newScale;
        });


        // --- Import / Export ---
        el.btnExport.addEventListener('click', () => {
            const dataStr = JSON.stringify(notes, null, 2);
            const blob = new Blob([dataStr], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `nexus_backup_${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
        });

        el.btnImport.addEventListener('click', () => el.fileImport.click());

        el.fileImport.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const imported = JSON.parse(event.target.result);
                    if (Array.isArray(imported)) {
                        if (confirm("This will overwrite your current notes. Continue?")) {
                            notes = imported;
                            saveNotes();
                            loadNotes();
                            alert("Import successful!");
                        }
                    } else {
                        alert("Invalid format.");
                    }
                } catch (err) {
                    alert("Error parsing JSON file.");
                }
            };
            reader.readAsText(file);
            el.fileImport.value = ''; // Reset
        });

        // --- Event Listeners ---
        el.btnNew.addEventListener('click', () => createNote());
        el.btnDelete.addEventListener('click', deleteCurrentNote);
        
        el.noteTitle.addEventListener('input', (e) => {
            const note = notes.find(n => n.id === activeNoteId);
            if (note) {
                note.title = e.target.value;
                saveNotes();
            }
        });

        el.mdInput.addEventListener('input', updatePreview);
        
        el.searchInput.addEventListener('input', renderSidebar);
        
        el.btnToggleView.addEventListener('click', toggleGraphView);
        el.btnCloseGraph.addEventListener('click', toggleGraphView);
        
        window.addEventListener('resize', () => {
            if (isGraphOpen) initGraph(); // Re-init canvas size
        });

        // --- Init ---
        loadNotes();

    </script>
</body>
</html>
